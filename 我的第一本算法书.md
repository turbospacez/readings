# 第1章 数据结构
## 1.1
决定数据顺序和位置关系的是数据结构

**电话簿的数据结构**
|按获取顺序排序|按拼音顺序排序|
| ---- | ---- |
|添加简单 查询麻烦|查询简单 添加麻烦|

**两者结合**

分别使用不同的表存储不同的首字母, 再将同一张表中的数据按获取顺序进行排序

**选择适合的数据结构可以提高内存的利用率**

## 1.2 链表
- 线性排列, 数据的添加和删除方便, 访问消耗时间
- 链表的每个数据都都有一个指针且这个指针指向下一个数据的内存地址
- 分散存储于内存中，无须在连续空间内
- 链表要访问数据, 需要按照指针方向顺序访问
- 添加数据改变指针前后指向
- 删除改变指针指向

 > 访问：O(n) 添加.删除：O(1)

补充：
1. 循环链表：链表尾部指针指向链表头. 链表变成环形
2. 双向链表：每个数据有前后两个指针. 
   1. 缺点：指针数增加导致存储空间需求增加
   2. 缺点：添加和删除数据需要改变更多指针指向

 ## 1.3 数组
 - 也是线性排列的数据结构. 访问简单, 添加和删除费时
 - 数组存储在连续空间内
 - 数组中的每个数据可以根据下标算出, 就可以直接访问目标数据 (随机访问)
 - 在数组中间添加或删除元素需要将后面的元素逐个移动再写入需要添加或删除的数据

> 访问O(1) 添加.删除O(n)

补充：
|    |访问|添加|删除|
|--- |---|--- |---|
|链表|慢 |快  |快| 
|数组|快 |慢  |慢| 

## 1.4 栈
- 线性排列
- 后进先出(Last In Fist Out, LIFO) 入栈(push) 出栈(pop)

> 应用场景：只需要访问最新数据. 深度优先搜索算法

## 1.5 队列
- 线性排列
- 先进先出(First In First Out, FIFO) 入队 出队

> 应用场景：先来的数据先处理. 广度优先搜索算法

## 1.6 哈希表
- 键值组成的数据 (键, 数据的标识符. 值, 数据的内容)
- 哈希函数计算变量值, 再将求余数. 得到的结果作为数组的下标存放
- 当发生哈希冲突时, 在数组下标的同一位置使用链表继续存储新的数据

> 开放地址法：发生哈希冲突时, 即刻计算一个候选地址, 如果还有冲突就再次计算另一个候选地址, 直到有空地址为止.
> 线性探测法

## 1.7 堆
- 图的树形结构, 用于优先队列(priority queues) 广度优先算法
- 子结点一定大于父结点. 最小值被存在顶端, 添加数据时, 新数据在最下面一行的左侧. 当下一行没有多余空间, 就再往下另起一行, 把数据加在这一行的最左端.
- 父结点大于子结点就要交换两者的位置
- 堆取出的是最上面的数据(最小的), 最后的数据移动到最顶端, 然后再次排序

  1. 优先队列：自由添加数据, 取出数据要从最小值开始按顺序取出
  2. 堆的树形结构中, 每个顶点成为 结点 node
  3. 每个结点最多两个子结点. 排列从上到下, 从左到右

> 取出O(1) 重构树O(logₙ) 添加树O(logₙ)

> 应用场景：狄克斯特拉算法

## 1.8 二叉查找树
- 图的树形结构 广度优先搜索
- 每个结点的值均大于其左子树上任意一个结点的值
- 每个结点的值均小于其右子树上任意一个结点的值
- 删除的结点没有子结点, 直接删掉该结点
- 删除的结点只有一个子结点, 那么先删掉目标结点, 然后把子结点移到被删除结点的位置上
- 如果需要删除的结点有两个子结点, 那么先删掉目标结点, 然后在被删除结点的左子树中寻找最大结点

> 二叉查找树当作是二分查找算法思想的树形结构体现
> 树形状较为均衡 O(logₙ) 树形状朝单侧纵向延伸 O(n)
> 把子结点数扩展为 m（m 为预先设定好的常数）。像这种子结点数可以自由设定，并且形状均衡的树便是 B 树

# # 第2章 排序
## 2.1 什么是排序
将输入的数字按照从小到大的顺序进行排列

## 2.2 冒泡排序
- 从右开始, 两两比较. 逐渐将最小值移动到最左侧
- 再从最左侧逐步往左移动, 直至所有数字均完成排序
- 时间复杂度 O(n²)， 比较n²/2次

## 2.3 选择排序
- 直接寻找最小值, 然后将最小值直接与最左侧数字交换
- 重复查找最小值再与左侧交换的过程直至完成排序
- 时间复杂度 O(n²)， 比较n²/2次

## 2.4 插入排序
- 完成排序的数据放在左侧, 右侧为尚未排序的数据
- 排序时, 将右侧数据取出未排序的数据并在左侧插入排序, 直至排序完成
- 时间复杂度 O(n²)

## 2.5 堆排序
- 利用数据结构中的堆
- 在堆中存储所有数据, 并将数据按降序构成堆
- 将堆中取出的数据反序输出, 排序完成
- 时间复杂度 O(nlogn)

## 2.6 归并排序
- 将序列分为两个长度相同的子序列, 当无法继续分开时, 对子序列进行归并
- 归并即将排好序的子序列合并成一个有序序列
- 时间复杂度 O(nlogn)


## 2.7 快速排序
- 序列中随机选择 基准值(pivot) 将其他数据划分为 "小于基准值"和"大于基准值"
- 完成划分后, 将基准值插回原位置, 然后再将划分好的两段数据进行排序
- 时间复杂度 O(nlogn)

# 第3章　数组的查找
## 3.1 线性查找
- 在数组中从头开始依次查询
- 时间复杂度 O(n)

## 3.2 二分查找
- **只能查找已经排好序的数据**, 比较一次把查找范围缩小一半, 多次重复即可
- 时间复杂度 O(logn)

# 第4章　图的搜索
## 4.1 什么是图
- 图中 圆圈"顶点" 连接顶线的线"边". 由顶点和链接每对顶点的边构成的图形就是图
- 图可以用于表示
  - 人际关系
  - 地铁路线
  - 网络链接状况
- 加权图：在图上给边加一个值
- 有向图：表示该路线只能单向

- 使用场景
  - 寻找计算机通信时间最短路线
  - 寻找路线图中耗时最短的路径
  - 寻找路线图中最省车费的路径

## 4.2 广度优先搜索
- 从起点开始搜索直至到达终点 搜索图的算法
- 从某个顶点开始搜索, 优先搜索距离起点近的顶点
- 从起点开始由近及远进行广泛的搜索

> 候补顶点使用 先入先出 可以使用队列

> 闭环

## 4.3 深度优先搜索
- 从起点开始搜索直至到达终点 搜索图的算法
- 沿着一条路径不断探索直至无法继续, 再折返 开始搜索下一条候补路径

> 候补顶点使用 后入后出 可以使用栈

区别：广度优先选择最早啊成为候补的顶点; 深度优先选择最新成为候补的顶点

## 4.4 贝尔曼 - 福特算法
- 图中求解最短路径
- 各顶点初始权重 无穷大, 起点0
- 计算候补顶点权重：当前顶点权重 + 边的权重. 结果小于候补顶点的值, 就会更新这个值
- 从起点开始选路线, 每一条路线都会走一遍, 直至所有权重不再更新, 找到最短路径
- 权重为负数也可以运行
- 时间复杂度 O(nm)

## 4.5 狄克斯特拉算法
- 图中求解最短路径
- 各顶点初始权重 无穷大, 起点0
- 计算候补顶点权重：当前顶点权重 + 当前顶点到候补顶点的权重. 结果小于候补顶点的值, 就会更新这个值
- 从起点开始选择权重最小的顶点
- 无法求解含有负数的路径
- 时间复杂度 O(m + nlogn)

> 贝尔曼 - 福特算法 对所有边都重复计算权重
> 狄克斯特拉算法 一边确定起点到各顶点的最短路径 一边对图进行搜索

## 4.6 A* 算法
- 图中求解最短路径
- 可以人工预先设定估算距离值, 便于算法使用. 启发式算法
- 可以得到一些启发信息, 可以选择 A star算法, 如果无法估算信息, 则不能使用A star算法

# 第5章 安全算法
## 5.1 安全和算法
**传输数据的四个问题**
1. 窃听
2. 假冒
3. 篡改
4. 事后否认

**解决这些问题的安全技术**
1. 窃听 → 加密
2. 假冒 → 消息认证码/数字签名
3. 篡改 → 消息认证码/数字签名
4. 事后否认 → 数字签名

## 5.2 加密的技术知识
- 密文：加密后的数据
- 解密：密文恢复为原本数据

## 5.3 哈希函数
将给定的数据转换为固定长度的无规律数值

**特征**
1. 输出的哈希值数据不变
2. 输入数据相同, 输出必定相同
3. 输入的数据有一点, 输出结果也会有很大不同
4. 输入两个完全不同的数据, 输出也可能相同 这种情况被称为"哈希冲突"
5. 不可能从哈希值反向推算出原本的数据
6. 哈希值计算相对容易

> 哈希函数算法代表：MD5、SHA-1 和 SHA-2

## 5.4 共享密钥加密
- 共享密钥加密
  - 加密解密使用相同密钥. 对称加密
  - 共享密钥加密算法：AES、DES、动态口令

- 公开密钥加密
  - 加密解密使用不同密钥. 非对称加密
  - 加密密钥 公开密钥; 解密密钥 私有密钥.
  - 公开密钥加密算法：RAS、椭圆曲线加密算法

- 中间人攻击：中途替换公开密钥窃听数据. 
- 公开密钥可能遭受的攻击
- 公开密钥加密解密比较耗时, 要持续发送零碎数据则需要使用混合加密

> 公开加密算法需要满足的条件：
> 1.可以使用某个数值对数据进行加密（计算）
> 2.使用另一个数值对加密数据进行计算就可以让数据恢复原样
> 3.无法从一种密钥推算出另一种密钥

> 共享密钥加密, 密钥需求会随着发送人数的增多而急剧增加
> n人需要： n(n - 1) / 2

## 5.6 混合加密
- 解决问题：
  - 共享密钥无法安全传输密钥
  - 公开加密密钥加密解密速度慢

- 使用非对称加密 加密 对称加密密钥
  - 解决非对称加密解密耗时问题, 只加密对称加密密钥
  - 又保证了对称加密密钥不会被窃听

> 通讯安全SSL协议使用混合加密. 版本升级后为TLS也被称为SSL/TLS协议

## 5.7 迪菲 - 赫尔曼密钥交换
1. 双方准备一个共享密钥P, 每人一份公开加密密钥SA/SB
2. 双方各自使用共享密钥P和自己的公开加密密钥SA/SB合成P-SA/P-SB
3. 相互交换P-SA/P-SB 
4. 再用自己的公开加密密钥和交换得到的密钥合成P-SA.SB

> 密钥之间可以合成 不能分解
> 所以交换的P-SA/P-SB 不会被窃听者获取密钥 P、SA和SB
> 自己再合成一份最终的包含两人公开加密和一份共享密钥即可传输信息

1. A(P, G) → B(P, G)
2. A(P, G. X) → B(P, G. Y)
3. Gˣ mod P | Gᵞ mod P
4. Gᵞ mod P ↔ Gˣ mod P
5. (Gᵞ mod P)ˣ mod P | (Gˣ mod P)ᵞ mod P

> 1.素数P 和 生成元G
> 2.AB 分别准备各自的秘密数字 X 和 Y. (XY必须小于 P-2)
> 3.A、B分别计算 G的秘密数字次方 并除以P的余数
> 4.A、B分别将结果发送给对方
> 5.A、B先计算这个值的秘密数字次方然后再除以P的余数

## 5.8 消息认证码
- 避免密文内容在传输过程中被篡改

1. 生成用于制作消息认证码的密钥, 使用安全的方法将密钥发送给B
2. 使用密文和密钥生成一个值, 这个值就是消息认证码(MAC)
3. 将MAC和密文发送
4. 对方也需要使用密文和密钥生成MAC. 自己计算后可以确认MAC是否一致
5. 如果MAC一致, 对方使用密钥对密文解密

> MAC可以想象成由密钥和密文组成的字符串"哈希值"
> 计算MAC算法：HMAC、OMAC、CMAC等
> 此方法可以避免通信过程中对信息的篡改, 但是无法防止发送后否认的情况

## 5.9 数字签名
- 实现消息认证码
- 检测篡改
- 预防事后否认

**数字签名的使用**
1. A 向 B 发送消息
2. A 在发送前在消息上加上数字签名. 数字签名只能由 A 生成, 只要发送消息上有 A 的数字签名, 就能确定消息的发送者是 A. B 可以验证数字签名的正确性, 但是无法生成数字签名

**生成数字签名**
1. 数字签名使用公开密钥加密
2. 将公开密钥发送给接收方, 自己保留私有密钥
3. 自己使用私有密钥加密消息. 加密后的消息就是数字签名
4. 将消息和数字签名发送给接收方即可

> 因为只有发送者自己拥有私有密钥, 所以数字签名只有发送者能够生成, 可以预防事后否认
> 由于公开密钥加密解密比较耗时, 为了节约时间, 通常会对消息的哈希值进行加密然后作为数字签名使用

## 5.10 数字证书
- 公开密钥加密 和 数字签名 无法保证公开密钥来自信息的发送者
- 为了保证公开密钥不会被第三方恶意替换, 出现了认证中心保存公开密钥证明

1. A 要向 认证中心(CA) 申请发行证书, 证明公开密钥由自己生成
2. 认证中心保管公开密钥和私有密钥
3. A将公开密钥和包含邮件信息的个人资料发送给认证中心, 证明自己身份
4. 认证中心确认后, 认证中心使用自己的私有密钥根据 A 的资料生成数字签名
5. 认证中心将生成的数字签名和资料放入同一个文件中, 再将这个文件发送给A
6. 这个文件就是 A 的数字证书
7. A 将公开密钥的数字证书发送给 B
8. B 收到数字证书后, 确认证书里的邮件是A的地址. B 获取认证中心的公开密钥
9. B 对证书内的签名进行验证, 判断它是否为认证中心给出的签名. 证书中的签名只能用认证中心的公开密钥进行验证

> 原则上 任何人都可以成为认证中心, 所以认证中心数量也比较多. 建议再经过政府审查的大型企业机构进行申请

# 第6章 聚类
## 6.1 什么是聚类
**将相似的对象分为一组**

聚类就是在输入多个数据时, 将"相似"的数据分为一组的操作.

**如何定义相似**

根据数据类型不同, 定义数据相似的标准也不同

## 6.2 k-means 算法
1. 准备需要聚类的数据, 然后决定簇的数量
2. 根据簇的数量随机选择几个点作为簇的中心点
3. 计算各个数据分别和中心点的哪一个点距离最近
4. 将数据分到相应簇中
5. 计算各个簇中数据的重心, 将中心点移动到这个重心点的位置上
6. 重复执行 "将数据分到相应簇中" 和 "将中心点移到重心的位置" 两个操作
7. 直至中心点不会发生变化为止

> 聚类算法还有 层次聚类算法
> 每个数据开始时都自成一派. n 个数据就有 n 个簇
> 然后重复执行 "将距离最近的两个簇合并为一个" n-1次
> 执行 n-1 次后, 所有数据都被分到了一个簇中

第7章 其他算法
## 7.1 欧几里得算法
欧几里得算法(辗转相除法)用于计算两个数的最大公约数

1. 用 较小数A 求 较大数B 的 余数C
2. 再用 C 求 A 的余数. 一直用较小数字求余较大数字, 再用余数继续求余较小数字
3. 重复相同操作, 直至余数为 0. 那么最后一次运算的除数就是两数的最大公约数

## 7.2 素性测试
判断一个自然数是否为素数的测试.

费马测试(概率性素性测试)

示例：测试素数5
1. 比5小的数字, 分别计算它们的5次方
2. 再对结果求关于5的余数
3. 结果仍为原本的数字

公式成立：

p = 素数

n < p

n^p mod p = n

费马小定理, 根据是否满足费马小定理来判断一个数是否为素数的方法就是 费马测试

> 素数是只能被 1 和其自己整除的, 且大于 1 的自然数
> 确认 n 和 余数一致的次数越多, 判断的数为素数的可能性就越大. 但是每一个小于 p 的数都要去计算, 就会非常耗时
> 有一些不是素数的数字也能满足费马小定理条件, 这种数字被称为 卡迈克尔数/绝对伪素数
> AKS算法：输入规模的多项式内进行素性测试

## 7.3 网页排名
网页排名(佩奇排名)

- 网页排名中, 链入的网页越多, 它的重要性就越高
- 链接结构为环状的情况下就会出现问题, 可以使用 随机游走模型 解决问题

## 7.4 汉诺塔
条件：
1. 1次移动1个圆盘
2. 不能把大圆盘放在小圆盘上

递归算法

T(n) = 2n -1



















